# Подробный план написания алгоритма
```
1. Открыть файл в бинарном виде на чтение и прочитать его в data

2. Открыть новый файл out_file в бинарном виде на запись

    3. Заполнить словарь dictionary
        Диапазон [0; 256)
        Ключ: число
        Значение: кортеж из одного элемента - числа

    4. Заводим пустой список sequence под последовательность

    5. Заводим итератор i, инициализированный нулем

    6. Основной цикл - пока i не достигнет длинны data (while)

        7. Считаем предварительную длину n:
            Если sequence пустая, то длина словаря
            иначе длина словаря + 1

        8. Количество бит nbits считаем по той же формуле, что и при сжатии:
            nbits = ceil(log2(n))

        9. Количество байт получаем делением на 8 в большую сторону
           (можно через целочисленное деление и деление с остатком)

        10. Из данных берем слайс данных: с i по i + nbytes

        11. Для получения назад из байт индекса sym используется функция int.from_bytes

        12. Сравниваем sym и длину словаря:
            * Если полученный sym равен длине словаря, то считаем новую последовательность
            * new_sequence как текущую + последний символ текущей
            * Иначе новая последовательность new_sequence будет получена напрямую из словаря
            * dictionary по ключу sym

        13. Полученную последовательность new_sequence пишем в файл out_file

        14. Заносим в словарь:
            Ключ: длина словаря
            Значение: sequence + последний символ new_sequence

        15. Увеличиваем i на nbytes

        16. sequence становится равна new_sequence
```